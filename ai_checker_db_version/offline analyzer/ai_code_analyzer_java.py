#!/usr/bin/env python3
"""
Improved AI Code Analyzer (Python version for Java code) - DB version

This script analyzes Java code stored in a SQLite database table `codes`
with columns: id (INTEGER), filename (TEXT), content (TEXT).

Algorithm preserved; only input source changed from terminal to DB.
"""

import re
import argparse
import sqlite3
import os

try:
    import javalang
except ImportError:
    javalang = None


def analyze_code(code):
    """
    Analyze Java code using heuristic rules.
    Returns dict with percentage, confidence, and reasoning list.
    """
    ai_score = 0
    reasons = []

    # Heuristic 1: AI-related comments
    if "generated by" in code.lower():
        ai_score += 50
        reasons.append("Detected 'Generated by' comment.")

    # Heuristic 2: Standardized Javadoc
    if "/**" in code and "*/" in code:
        ai_score += 20
        reasons.append("Standardized Javadoc formatting found.")

    # Heuristic 3: Uniform indentation
    lines = [l for l in code.splitlines() if l.strip()]
    if lines:
        indentations = [len(l) - len(l.lstrip(" ")) for l in lines]
        common_indent = max(set(indentations), key=indentations.count)
        uniformity = sum(1 for i in indentations if i == common_indent) / len(indentations) * 100
        if uniformity > 70:
            ai_score += 15
            reasons.append("Consistent indentation suggests AI formatting.")

    # Heuristic 4: Repetitive method structures
    method_count = code.count("public ") + code.count("private ") + code.count("protected ")
    if method_count > 5:
        ai_score += 10
        reasons.append("Repetitive method structures detected.")

    # Heuristic 5: Simple variable names
    simple_vars = re.findall(r"(int|double|String|boolean|float|long)\s+[a-zA-Z]\s*;", code)
    if len(simple_vars) > 2:
        ai_score += 10
        reasons.append("Simple one-letter variable names detected.")

    # Heuristic 6: Low complexity
    if len(code) < 300:
        ai_score += 15
        reasons.append("Short code snippet with low complexity.")

    # Heuristic 7: Overuse of generic method names
    generic_methods = re.findall(r"void\s+(getData|process|doSomething|handle|run)\s*\(", code)
    if generic_methods:
        ai_score += 10
        reasons.append(f"Generic method names found: {', '.join(set(generic_methods))}.")

    # Heuristic 8: Comment-to-code ratio
    comment_lines = [l for l in lines if l.strip().startswith("//") or l.strip().startswith("/*")]
    if lines:
        ratio = len(comment_lines) / len(lines)
        if ratio > 0.4:
            ai_score += 10
            reasons.append("High comment-to-code ratio (AI-style verbose code).")
        elif ratio < 0.05:
            ai_score += 5
            reasons.append("Very few comments (minimalistic AI style).")

    # Heuristic 9: Naming conventions (uniform case style)
    identifiers = re.findall(r"\b[a-zA-Z_][a-zA-Z0-9_]*\b", code)
    if identifiers:
        camel_case = sum(1 for idf in identifiers if re.match(r"^[a-z]+([A-Z][a-z0-9]+)+$", idf))
        snake_case = sum(1 for idf in identifiers if "_" in idf)
        if camel_case / len(identifiers) > 0.8:
            ai_score += 10
            reasons.append("Highly uniform camelCase naming convention.")
        elif snake_case / len(identifiers) > 0.8:
            ai_score += 10
            reasons.append("Highly uniform snake_case naming convention.")

    # Heuristic 10: javalang parsing (optional)
    if javalang:
        try:
            tree = javalang.parse.parse(code)
            method_lengths = []
            for _, node in tree:
                if isinstance(node, javalang.tree.MethodDeclaration) and node.body:
                    method_lengths.append(len(node.body))
            if method_lengths and all(l < 5 for l in method_lengths):
                ai_score += 10
                reasons.append("Methods are very short and uniform.")
        except Exception:
            reasons.append("Parsing failed: code may be invalid Java.")

    # Final scoring
    percentage = min(100, ai_score)
    confidence = min(100, 50 + ai_score // 2)

    if not reasons:
        reasons.append("No strong AI patterns detected; looks mostly human-written.")

    return {
        "percentage": percentage,
        "confidence": confidence,
        "reasoning": reasons
    }


def fetch_codes_from_db(db_path: str):
    if not os.path.exists(db_path):
        raise FileNotFoundError(f"Database not found at: {db_path}")
    conn = sqlite3.connect(db_path)
    try:
        cur = conn.cursor()
        cur.execute("SELECT id, filename, content FROM codes ORDER BY id ASC")
        for row in cur.fetchall():
            yield row
    finally:
        conn.close()


def main():
    parser = argparse.ArgumentParser(description="AI Code Analyzer for Java (SQLite-driven)")
    parser.add_argument("--db", dest="db_path", default="./codes.db", help="Path to SQLite database containing table 'codes'")
    args = parser.parse_args()

    print("=== Improved AI Code Analyzer (Python for Java) - DB ===")
    any_row = False
    for code_id, filename, content in fetch_codes_from_db(args.db_path):
        any_row = True
        print(f"\n--- Analyzing: id={code_id}, file='{filename}' ---")
        code = content or ""
        if not code.strip():
            print("No code entered.")
            continue
        print("Analyzing code...\n")
        result = analyze_code(code)
        print(f"Estimated AI Involvement: {result['percentage']}%")
        print("Reasoning:")
        for r in result['reasoning']:
            print(f" - {r}")
        print(f"Confidence Score: {result['confidence']}%\n")

    if not any_row:
        print("No rows found in table 'codes'.")


if __name__ == "__main__":
    main()

