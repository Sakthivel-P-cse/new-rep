#!/usr/bin/env python3
"""
ai_code_analyzer_python.py (DB version)
--------------------------------------
A tool to analyze Python code and estimate AI involvement.

This version reads code snippets from a local SQLite database table `codes`
with columns: id (INTEGER), filename (TEXT), content (TEXT).

Algorithm is preserved from the terminal-input version. Only database
connectivity and I/O have been added.

Author: Sakthi's AI Analyzer (example)
"""

import ast
import re
import statistics
import sqlite3
import argparse
import os


def analyze_code(code: str):
    """
    Analyze code heuristically and return AI involvement estimate.
    Returns:
        percentage (int), confidence (int), reasons (list of str)
    """
    reasons = []
    ai_score = 0
    confidence = 50  # base confidence

    # 1. Check for AI-generated comments or metadata
    if re.search(r"(generated by|chatgpt|copilot|ai)", code, re.I):
        ai_score += 40
        confidence += 20
        reasons.append("Presence of AI-generated comment or metadata detected.")

    # 2. Check for repetitive code structures
    lines = [l.strip() for l in code.splitlines() if l.strip()]
    if len(lines) > 5:
        unique_lines = set(lines)
        repetition_ratio = 1 - (len(unique_lines) / len(lines))
        if repetition_ratio > 0.3:
            ai_score += 20
            confidence += 10
            reasons.append("High repetition ratio in code structure.")

    # 3. Check naming conventions (uniformity = AI-like)
    identifiers = re.findall(r"\b[a-zA-Z_][a-zA-Z0-9_]*\b", code)
    if identifiers:
        avg_len = statistics.mean(len(i) for i in identifiers)
        if avg_len < 4:  # very short names (a, b, c)
            ai_score += 10
            reasons.append("Short, uniform variable names detected.")
        elif avg_len > 10:  # very long descriptive names
            ai_score += 10
            reasons.append("Overly uniform descriptive names detected.")

    # 4. Syntax validation and complexity analysis
    try:
        tree = ast.parse(code)
        func_defs = [n for n in ast.walk(tree) if isinstance(n, ast.FunctionDef)]

        if func_defs:
            func_lengths = [len(f.body) for f in func_defs]
            avg_func_len = statistics.mean(func_lengths)
            if avg_func_len < 3:
                ai_score += 10
                reasons.append("Very short, minimalistic functions suggest AI boilerplate.")
            elif avg_func_len > 50:
                ai_score += 10
                reasons.append("Overly long functions with uniform blocks suggest AI generation.")

        # Cyclomatic complexity approximation (count branches)
        branch_nodes = (ast.If, ast.For, ast.While, ast.Try, ast.With)
        branch_count = sum(isinstance(n, branch_nodes) for n in ast.walk(tree))
        if branch_count < 2 and func_defs:
            ai_score += 10
            reasons.append("Low branch complexity compared to number of functions.")

    except SyntaxError:
        reasons.append("Invalid Python syntax detected. Reduced confidence.")
        confidence -= 20

    # Normalize AI score (0-100)
    ai_score = min(100, ai_score)
    confidence = max(10, min(100, confidence))

    # Explanation
    if not reasons:
        reasons.append("No strong AI indicators found. Likely human-written.")

    return ai_score, confidence, reasons


def fetch_codes_from_db(db_path: str):
    """Yield (id, filename, content) rows from the SQLite database."""
    if not os.path.exists(db_path):
        raise FileNotFoundError(f"Database not found at: {db_path}")

    conn = sqlite3.connect(db_path)
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT id, filename, content FROM codes ORDER BY id ASC")
        for row in cursor.fetchall():
            yield row  # (id, filename, content)
    finally:
        conn.close()


def main():
    parser = argparse.ArgumentParser(description="AI Code Analyzer (SQLite-driven)")
    parser.add_argument("--db", dest="db_path", default="./codes.db", help="Path to SQLite database containing table 'codes' with columns (id, filename, content)")
    args = parser.parse_args()

    print("=== AI Code Analyzer (DB) ===")
    try:
        any_row = False
        for code_id, filename, content in fetch_codes_from_db(args.db_path):
            any_row = True
            print(f"\n--- Analyzing: id={code_id}, file='{filename}' ---")
            if not content or not str(content).strip():
                print("No code entered.")
                continue
            print("Analyzing code...")
            ai_percentage, confidence, reasons = analyze_code(str(content))
            print(f"\nEstimated AI Involvement: {ai_percentage}%")
            print(f"Confidence Score: {confidence}%")
            print("Reasoning:")
            for r in reasons:
                print(f"- {r}")

        if not any_row:
            print("No rows found in table 'codes'.")

    except Exception as exc:
        print(f"Error: {exc}")


if __name__ == "__main__":
    main()

