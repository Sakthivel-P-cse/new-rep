#!/usr/bin/env python3
"""
Improved AI Code Analyzer (Python version for Java code)

This script analyzes Java code entered by the user in the terminal
and estimates the percentage of AI involvement using heuristic checks.

Improvements:
- More heuristics (naming, comments, method patterns)
- Rebalanced weights
- Cleaner reasoning output
"""

import re

try:
    import javalang
except ImportError:
    javalang = None


def read_code_input():
    """Reads multi-line Java code from the terminal until 'END' is entered."""
    print("\nEnter Java code (type 'END' on a new line to finish):")
    code_lines = []
    while True:
        try:
            line = input()
        except EOFError:
            break
        if line.strip().upper() == "END":
            break
        code_lines.append(line)
    return "\n".join(code_lines)


def analyze_code(code):
    """
    Analyze Java code using heuristic rules.
    Returns dict with percentage, confidence, and reasoning list.
    """
    ai_score = 0
    reasons = []

    # Heuristic 1: AI-related comments
    if "generated by" in code.lower():
        ai_score += 50
        reasons.append("Detected 'Generated by' comment.")

    # Heuristic 2: Standardized Javadoc
    if "/**" in code and "*/" in code:
        ai_score += 20
        reasons.append("Standardized Javadoc formatting found.")

    # Heuristic 3: Uniform indentation
    lines = [l for l in code.splitlines() if l.strip()]
    if lines:
        indentations = [len(l) - len(l.lstrip(" ")) for l in lines]
        common_indent = max(set(indentations), key=indentations.count)
        uniformity = sum(1 for i in indentations if i == common_indent) / len(indentations) * 100
        if uniformity > 70:
            ai_score += 15
            reasons.append("Consistent indentation suggests AI formatting.")

    # Heuristic 4: Repetitive method structures
    method_count = code.count("public ") + code.count("private ") + code.count("protected ")
    if method_count > 5:
        ai_score += 10
        reasons.append("Repetitive method structures detected.")

    # Heuristic 5: Simple variable names
    simple_vars = re.findall(r"(int|double|String|boolean|float|long)\s+[a-zA-Z]\s*;", code)
    if len(simple_vars) > 2:
        ai_score += 10
        reasons.append("Simple one-letter variable names detected.")

    # Heuristic 6: Low complexity
    if len(code) < 300:
        ai_score += 15
        reasons.append("Short code snippet with low complexity.")

    # Heuristic 7: Overuse of generic method names
    generic_methods = re.findall(r"void\s+(getData|process|doSomething|handle|run)\s*\(", code)
    if generic_methods:
        ai_score += 10
        reasons.append(f"Generic method names found: {', '.join(set(generic_methods))}.")

    # Heuristic 8: Comment-to-code ratio
    comment_lines = [l for l in lines if l.strip().startswith("//") or l.strip().startswith("/*")]
    if lines:
        ratio = len(comment_lines) / len(lines)
        if ratio > 0.4:
            ai_score += 10
            reasons.append("High comment-to-code ratio (AI-style verbose code).")
        elif ratio < 0.05:
            ai_score += 5
            reasons.append("Very few comments (minimalistic AI style).")

    # Heuristic 9: Naming conventions (uniform case style)
    identifiers = re.findall(r"\b[a-zA-Z_][a-zA-Z0-9_]*\b", code)
    if identifiers:
        camel_case = sum(1 for idf in identifiers if re.match(r"^[a-z]+([A-Z][a-z0-9]+)+$", idf))
        snake_case = sum(1 for idf in identifiers if "_" in idf)
        if camel_case / len(identifiers) > 0.8:
            ai_score += 10
            reasons.append("Highly uniform camelCase naming convention.")
        elif snake_case / len(identifiers) > 0.8:
            ai_score += 10
            reasons.append("Highly uniform snake_case naming convention.")

    # Heuristic 10: javalang parsing (optional)
    if javalang:
        try:
            tree = javalang.parse.parse(code)
            method_lengths = []
            for _, node in tree:
                if isinstance(node, javalang.tree.MethodDeclaration) and node.body:
                    method_lengths.append(len(node.body))
            if method_lengths and all(l < 5 for l in method_lengths):
                ai_score += 10
                reasons.append("Methods are very short and uniform.")
        except Exception:
            reasons.append("Parsing failed: code may be invalid Java.")

    # Final scoring
    percentage = min(100, ai_score)
    confidence = min(100, 50 + ai_score // 2)

    if not reasons:
        reasons.append("No strong AI patterns detected; looks mostly human-written.")

    return {
        "percentage": percentage,
        "confidence": confidence,
        "reasoning": reasons
    }


def main():
    print("=== Improved AI Code Analyzer (Python for Java) ===")
    while True:
        code = read_code_input()
        if not code.strip():
            print("No code entered. Please try again.")
            continue

        print("Analyzing code...\n")
        result = analyze_code(code)

        print(f"Estimated AI Involvement: {result['percentage']}%")
        print("Reasoning:")
        for r in result['reasoning']:
            print(f" - {r}")
        print(f"Confidence Score: {result['confidence']}%\n")

        choice = input("Analyze another code? (y/n): ").strip().lower()
        if choice != "y":
            print("Exiting AI Code Analyzer. Goodbye!")
            break


if __name__ == "__main__":
    main()
